// ignore_for_file: unused_element, unused_field

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to libfuse
class DartFuse {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  DartFuse(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Create a FUSE mountpoint
  ///
  /// Returns a control file descriptor suitable for passing to
  /// fuse_new()
  ///
  /// @param mountpoint the mount point path
  /// @param args argument vector
  /// @return the communication channel on success, NULL on failure
  ffi.Pointer<fuse_chan> fuse_mount(
    ffi.Pointer<ffi.Int8> mountpoint,
    ffi.Pointer<fuse_args> args,
  ) {
    return (_fuse_mount ??=
        _dylib.lookupFunction<_c_fuse_mount, _dart_fuse_mount>('fuse_mount'))(
      mountpoint,
      args,
    );
  }

  _dart_fuse_mount? _fuse_mount;

  /// Umount a FUSE mountpoint
  ///
  /// @param mountpoint the mount point path
  /// @param ch the communication channel
  void fuse_unmount(
    ffi.Pointer<ffi.Int8> mountpoint,
    ffi.Pointer<fuse_chan> ch,
  ) {
    return (_fuse_unmount ??= _dylib
        .lookupFunction<_c_fuse_unmount, _dart_fuse_unmount>('fuse_unmount'))(
      mountpoint,
      ch,
    );
  }

  _dart_fuse_unmount? _fuse_unmount;

  /// Parse common options
  ///
  /// The following options are parsed:
  ///
  /// '-f'	     foreground
  /// '-d' '-odebug'  foreground, but keep the debug option
  /// '-s'	     single threaded
  /// '-h' '--help'   help
  /// '-ho'	     help without header
  /// '-ofsname=..'   file system name, if not present, then set to the program
  /// name
  ///
  /// All parameters may be NULL
  ///
  /// @param args argument vector
  /// @param mountpoint the returned mountpoint, should be freed after use
  /// @param multithreaded set to 1 unless the '-s' option is present
  /// @param foreground set to 1 if one of the relevant options is present
  /// @return 0 on success, -1 on failure
  int fuse_parse_cmdline(
    ffi.Pointer<fuse_args> args,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
    ffi.Pointer<ffi.Int32> multithreaded,
    ffi.Pointer<ffi.Int32> foreground,
  ) {
    return (_fuse_parse_cmdline ??=
        _dylib.lookupFunction<_c_fuse_parse_cmdline, _dart_fuse_parse_cmdline>(
            'fuse_parse_cmdline'))(
      args,
      mountpoint,
      multithreaded,
      foreground,
    );
  }

  _dart_fuse_parse_cmdline? _fuse_parse_cmdline;

  /// Go into the background
  ///
  /// @param foreground if true, stay in the foreground
  /// @return 0 on success, -1 on failure
  int fuse_daemonize(
    int foreground,
  ) {
    return (_fuse_daemonize ??=
        _dylib.lookupFunction<_c_fuse_daemonize, _dart_fuse_daemonize>(
            'fuse_daemonize'))(
      foreground,
    );
  }

  _dart_fuse_daemonize? _fuse_daemonize;

  /// Get the version of the library
  ///
  /// @return the version
  int fuse_version() {
    return (_fuse_version ??= _dylib
        .lookupFunction<_c_fuse_version, _dart_fuse_version>('fuse_version'))();
  }

  _dart_fuse_version? _fuse_version;

  /// Destroy poll handle
  ///
  /// @param ph the poll handle
  void fuse_pollhandle_destroy(
    ffi.Pointer<fuse_pollhandle> ph,
  ) {
    return (_fuse_pollhandle_destroy ??= _dylib.lookupFunction<
        _c_fuse_pollhandle_destroy,
        _dart_fuse_pollhandle_destroy>('fuse_pollhandle_destroy'))(
      ph,
    );
  }

  _dart_fuse_pollhandle_destroy? _fuse_pollhandle_destroy;

  /// Get total size of data in a fuse buffer vector
  ///
  /// @param bufv buffer vector
  /// @return size of data
  int fuse_buf_size(
    ffi.Pointer<fuse_bufvec> bufv,
  ) {
    return (_fuse_buf_size ??=
        _dylib.lookupFunction<_c_fuse_buf_size, _dart_fuse_buf_size>(
            'fuse_buf_size'))(
      bufv,
    );
  }

  _dart_fuse_buf_size? _fuse_buf_size;

  /// Copy data from one buffer vector to another
  ///
  /// @param dst destination buffer vector
  /// @param src source buffer vector
  /// @param flags flags controlling the copy
  /// @return actual number of bytes copied or -errno on error
  int fuse_buf_copy(
    ffi.Pointer<fuse_bufvec> dst,
    ffi.Pointer<fuse_bufvec> src,
    int flags,
  ) {
    return (_fuse_buf_copy ??=
        _dylib.lookupFunction<_c_fuse_buf_copy, _dart_fuse_buf_copy>(
            'fuse_buf_copy'))(
      dst,
      src,
      flags,
    );
  }

  _dart_fuse_buf_copy? _fuse_buf_copy;

  /// Exit session on HUP, TERM and INT signals and ignore PIPE signal
  ///
  /// Stores session in a global variable.	 May only be called once per
  /// process until fuse_remove_signal_handlers() is called.
  ///
  /// @param se the session to exit
  /// @return 0 on success, -1 on failure
  int fuse_set_signal_handlers(
    ffi.Pointer<fuse_session> se,
  ) {
    return (_fuse_set_signal_handlers ??= _dylib.lookupFunction<
        _c_fuse_set_signal_handlers,
        _dart_fuse_set_signal_handlers>('fuse_set_signal_handlers'))(
      se,
    );
  }

  _dart_fuse_set_signal_handlers? _fuse_set_signal_handlers;

  /// Restore default signal handlers
  ///
  /// Resets global session.  After this fuse_set_signal_handlers() may
  /// be called again.
  ///
  /// @param se the same session as given in fuse_set_signal_handlers()
  void fuse_remove_signal_handlers(
    ffi.Pointer<fuse_session> se,
  ) {
    return (_fuse_remove_signal_handlers ??= _dylib.lookupFunction<
        _c_fuse_remove_signal_handlers,
        _dart_fuse_remove_signal_handlers>('fuse_remove_signal_handlers'))(
      se,
    );
  }

  _dart_fuse_remove_signal_handlers? _fuse_remove_signal_handlers;

  /// Create a new FUSE filesystem.
  ///
  /// @param ch the communication channel
  /// @param args argument vector
  /// @param op the filesystem operations
  /// @param op_size the size of the fuse_operations structure
  /// @param user_data user data supplied in the context during the init() method
  /// @return the created FUSE handle
  ffi.Pointer<fuse> fuse_new(
    ffi.Pointer<fuse_chan> ch,
    ffi.Pointer<fuse_args> args,
    ffi.Pointer<fuse_operations> op,
    int op_size,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return (_fuse_new ??=
        _dylib.lookupFunction<_c_fuse_new, _dart_fuse_new>('fuse_new'))(
      ch,
      args,
      op,
      op_size,
      user_data,
    );
  }

  _dart_fuse_new? _fuse_new;

  /// Destroy the FUSE handle.
  ///
  /// The communication channel attached to the handle is also destroyed.
  ///
  /// NOTE: This function does not unmount the filesystem.	 If this is
  /// needed, call fuse_unmount() before calling this function.
  ///
  /// @param f the FUSE handle
  void fuse_destroy(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_destroy ??= _dylib
        .lookupFunction<_c_fuse_destroy, _dart_fuse_destroy>('fuse_destroy'))(
      f,
    );
  }

  _dart_fuse_destroy? _fuse_destroy;

  /// FUSE event loop.
  ///
  /// Requests from the kernel are processed, and the appropriate
  /// operations are called.
  ///
  /// @param f the FUSE handle
  /// @return 0 if no error occurred, -1 otherwise
  int fuse_loop(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_loop ??=
        _dylib.lookupFunction<_c_fuse_loop, _dart_fuse_loop>('fuse_loop'))(
      f,
    );
  }

  _dart_fuse_loop? _fuse_loop;

  /// Exit from event loop
  ///
  /// @param f the FUSE handle
  void fuse_exit(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_exit ??=
        _dylib.lookupFunction<_c_fuse_exit, _dart_fuse_exit>('fuse_exit'))(
      f,
    );
  }

  _dart_fuse_exit? _fuse_exit;

  /// FUSE event loop with multiple threads
  ///
  /// Requests from the kernel are processed, and the appropriate
  /// operations are called.  Request are processed in parallel by
  /// distributing them between multiple threads.
  ///
  /// Calling this function requires the pthreads library to be linked to
  /// the application.
  ///
  /// @param f the FUSE handle
  /// @return 0 if no error occurred, -1 otherwise
  int fuse_loop_mt(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_loop_mt ??= _dylib
        .lookupFunction<_c_fuse_loop_mt, _dart_fuse_loop_mt>('fuse_loop_mt'))(
      f,
    );
  }

  _dart_fuse_loop_mt? _fuse_loop_mt;

  /// Get the current supplementary group IDs for the current request
  ///
  /// Similar to the getgroups(2) system call, except the return value is
  /// always the total number of group IDs, even if it is larger than the
  /// specified size.
  ///
  /// The current fuse kernel module in linux (as of 2.6.30) doesn't pass
  /// the group list to userspace, hence this function needs to parse
  /// "/proc/$TID/task/$TID/status" to get the group IDs.
  ///
  /// This feature may not be supported on all operating systems.  In
  /// such a case this function will return -ENOSYS.
  ///
  /// @param size size of given array
  /// @param list array of group IDs to be filled in
  /// @return the total number of supplementary group IDs or -errno on failure
  int fuse_getgroups(
    int size,
    ffi.Pointer<ffi.Uint32> list,
  ) {
    return (_fuse_getgroups ??=
        _dylib.lookupFunction<_c_fuse_getgroups, _dart_fuse_getgroups>(
            'fuse_getgroups'))(
      size,
      list,
    );
  }

  _dart_fuse_getgroups? _fuse_getgroups;

  /// Check if the current request has already been interrupted
  ///
  /// @return 1 if the request has been interrupted, 0 otherwise
  int fuse_interrupted() {
    return (_fuse_interrupted ??=
        _dylib.lookupFunction<_c_fuse_interrupted, _dart_fuse_interrupted>(
            'fuse_interrupted'))();
  }

  _dart_fuse_interrupted? _fuse_interrupted;

  /// Obsolete, doesn't do anything
  ///
  /// @return -EINVAL
  int fuse_invalidate(
    ffi.Pointer<fuse> f,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return (_fuse_invalidate ??=
        _dylib.lookupFunction<_c_fuse_invalidate, _dart_fuse_invalidate>(
            'fuse_invalidate'))(
      f,
      path,
    );
  }

  _dart_fuse_invalidate? _fuse_invalidate;

  int fuse_is_lib_option(
    ffi.Pointer<ffi.Int8> opt,
  ) {
    return (_fuse_is_lib_option ??=
        _dylib.lookupFunction<_c_fuse_is_lib_option, _dart_fuse_is_lib_option>(
            'fuse_is_lib_option'))(
      opt,
    );
  }

  _dart_fuse_is_lib_option? _fuse_is_lib_option;

  /// Start the cleanup thread when using option "remember".
  ///
  /// This is done automatically by fuse_loop_mt()
  /// @param fuse struct fuse pointer for fuse instance
  /// @return 0 on success and -1 on error
  int fuse_start_cleanup_thread(
    ffi.Pointer<fuse> fuse,
  ) {
    return (_fuse_start_cleanup_thread ??= _dylib.lookupFunction<
        _c_fuse_start_cleanup_thread,
        _dart_fuse_start_cleanup_thread>('fuse_start_cleanup_thread'))(
      fuse,
    );
  }

  _dart_fuse_start_cleanup_thread? _fuse_start_cleanup_thread;

  /// Stop the cleanup thread when using option "remember".
  ///
  /// This is done automatically by fuse_loop_mt()
  /// @param fuse struct fuse pointer for fuse instance
  void fuse_stop_cleanup_thread(
    ffi.Pointer<fuse> fuse,
  ) {
    return (_fuse_stop_cleanup_thread ??= _dylib.lookupFunction<
        _c_fuse_stop_cleanup_thread,
        _dart_fuse_stop_cleanup_thread>('fuse_stop_cleanup_thread'))(
      fuse,
    );
  }

  _dart_fuse_stop_cleanup_thread? _fuse_stop_cleanup_thread;

  /// Iterate over cache removing stale entries
  /// use in conjunction with "-oremember"
  ///
  /// NOTE: This is already done for the standard sessions
  ///
  /// @param fuse struct fuse pointer for fuse instance
  /// @return the number of seconds until the next cleanup
  int fuse_clean_cache(
    ffi.Pointer<fuse> fuse,
  ) {
    return (_fuse_clean_cache ??=
        _dylib.lookupFunction<_c_fuse_clean_cache, _dart_fuse_clean_cache>(
            'fuse_clean_cache'))(
      fuse,
    );
  }

  _dart_fuse_clean_cache? _fuse_clean_cache;

  int fuse_fs_getattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<stat> buf,
  ) {
    return (_fuse_fs_getattr ??=
        _dylib.lookupFunction<_c_fuse_fs_getattr, _dart_fuse_fs_getattr>(
            'fuse_fs_getattr'))(
      fs,
      path,
      buf,
    );
  }

  _dart_fuse_fs_getattr? _fuse_fs_getattr;

  int fuse_fs_fgetattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<stat> buf,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_fgetattr ??=
        _dylib.lookupFunction<_c_fuse_fs_fgetattr, _dart_fuse_fs_fgetattr>(
            'fuse_fs_fgetattr'))(
      fs,
      path,
      buf,
      fi,
    );
  }

  _dart_fuse_fs_fgetattr? _fuse_fs_fgetattr;

  int fuse_fs_rename(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> oldpath,
    ffi.Pointer<ffi.Int8> newpath,
  ) {
    return (_fuse_fs_rename ??=
        _dylib.lookupFunction<_c_fuse_fs_rename, _dart_fuse_fs_rename>(
            'fuse_fs_rename'))(
      fs,
      oldpath,
      newpath,
    );
  }

  _dart_fuse_fs_rename? _fuse_fs_rename;

  int fuse_fs_unlink(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return (_fuse_fs_unlink ??=
        _dylib.lookupFunction<_c_fuse_fs_unlink, _dart_fuse_fs_unlink>(
            'fuse_fs_unlink'))(
      fs,
      path,
    );
  }

  _dart_fuse_fs_unlink? _fuse_fs_unlink;

  int fuse_fs_rmdir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return (_fuse_fs_rmdir ??=
        _dylib.lookupFunction<_c_fuse_fs_rmdir, _dart_fuse_fs_rmdir>(
            'fuse_fs_rmdir'))(
      fs,
      path,
    );
  }

  _dart_fuse_fs_rmdir? _fuse_fs_rmdir;

  int fuse_fs_symlink(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> linkname,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return (_fuse_fs_symlink ??=
        _dylib.lookupFunction<_c_fuse_fs_symlink, _dart_fuse_fs_symlink>(
            'fuse_fs_symlink'))(
      fs,
      linkname,
      path,
    );
  }

  _dart_fuse_fs_symlink? _fuse_fs_symlink;

  int fuse_fs_link(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> oldpath,
    ffi.Pointer<ffi.Int8> newpath,
  ) {
    return (_fuse_fs_link ??= _dylib
        .lookupFunction<_c_fuse_fs_link, _dart_fuse_fs_link>('fuse_fs_link'))(
      fs,
      oldpath,
      newpath,
    );
  }

  _dart_fuse_fs_link? _fuse_fs_link;

  int fuse_fs_release(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_release ??=
        _dylib.lookupFunction<_c_fuse_fs_release, _dart_fuse_fs_release>(
            'fuse_fs_release'))(
      fs,
      path,
      fi,
    );
  }

  _dart_fuse_fs_release? _fuse_fs_release;

  int fuse_fs_open(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_open ??= _dylib
        .lookupFunction<_c_fuse_fs_open, _dart_fuse_fs_open>('fuse_fs_open'))(
      fs,
      path,
      fi,
    );
  }

  _dart_fuse_fs_open? _fuse_fs_open;

  int fuse_fs_read(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> buf,
    int size,
    int off,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_read ??= _dylib
        .lookupFunction<_c_fuse_fs_read, _dart_fuse_fs_read>('fuse_fs_read'))(
      fs,
      path,
      buf,
      size,
      off,
      fi,
    );
  }

  _dart_fuse_fs_read? _fuse_fs_read;

  int fuse_fs_read_buf(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Pointer<fuse_bufvec>> bufp,
    int size,
    int off,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_read_buf ??=
        _dylib.lookupFunction<_c_fuse_fs_read_buf, _dart_fuse_fs_read_buf>(
            'fuse_fs_read_buf'))(
      fs,
      path,
      bufp,
      size,
      off,
      fi,
    );
  }

  _dart_fuse_fs_read_buf? _fuse_fs_read_buf;

  int fuse_fs_write(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> buf,
    int size,
    int off,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_write ??=
        _dylib.lookupFunction<_c_fuse_fs_write, _dart_fuse_fs_write>(
            'fuse_fs_write'))(
      fs,
      path,
      buf,
      size,
      off,
      fi,
    );
  }

  _dart_fuse_fs_write? _fuse_fs_write;

  int fuse_fs_write_buf(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_bufvec> buf,
    int off,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_write_buf ??=
        _dylib.lookupFunction<_c_fuse_fs_write_buf, _dart_fuse_fs_write_buf>(
            'fuse_fs_write_buf'))(
      fs,
      path,
      buf,
      off,
      fi,
    );
  }

  _dart_fuse_fs_write_buf? _fuse_fs_write_buf;

  int fuse_fs_fsync(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int datasync,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_fsync ??=
        _dylib.lookupFunction<_c_fuse_fs_fsync, _dart_fuse_fs_fsync>(
            'fuse_fs_fsync'))(
      fs,
      path,
      datasync,
      fi,
    );
  }

  _dart_fuse_fs_fsync? _fuse_fs_fsync;

  int fuse_fs_flush(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_flush ??=
        _dylib.lookupFunction<_c_fuse_fs_flush, _dart_fuse_fs_flush>(
            'fuse_fs_flush'))(
      fs,
      path,
      fi,
    );
  }

  _dart_fuse_fs_flush? _fuse_fs_flush;

  int fuse_fs_statfs(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<statvfs> buf,
  ) {
    return (_fuse_fs_statfs ??=
        _dylib.lookupFunction<_c_fuse_fs_statfs, _dart_fuse_fs_statfs>(
            'fuse_fs_statfs'))(
      fs,
      path,
      buf,
    );
  }

  _dart_fuse_fs_statfs? _fuse_fs_statfs;

  int fuse_fs_opendir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_opendir ??=
        _dylib.lookupFunction<_c_fuse_fs_opendir, _dart_fuse_fs_opendir>(
            'fuse_fs_opendir'))(
      fs,
      path,
      fi,
    );
  }

  _dart_fuse_fs_opendir? _fuse_fs_opendir;

  int fuse_fs_readdir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Void> buf,
    ffi.Pointer<ffi.NativeFunction<fuse_fill_dir_t>> filler,
    int off,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_readdir ??=
        _dylib.lookupFunction<_c_fuse_fs_readdir, _dart_fuse_fs_readdir>(
            'fuse_fs_readdir'))(
      fs,
      path,
      buf,
      filler,
      off,
      fi,
    );
  }

  _dart_fuse_fs_readdir? _fuse_fs_readdir;

  int fuse_fs_fsyncdir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int datasync,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_fsyncdir ??=
        _dylib.lookupFunction<_c_fuse_fs_fsyncdir, _dart_fuse_fs_fsyncdir>(
            'fuse_fs_fsyncdir'))(
      fs,
      path,
      datasync,
      fi,
    );
  }

  _dart_fuse_fs_fsyncdir? _fuse_fs_fsyncdir;

  int fuse_fs_releasedir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_releasedir ??=
        _dylib.lookupFunction<_c_fuse_fs_releasedir, _dart_fuse_fs_releasedir>(
            'fuse_fs_releasedir'))(
      fs,
      path,
      fi,
    );
  }

  _dart_fuse_fs_releasedir? _fuse_fs_releasedir;

  int fuse_fs_create(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_create ??=
        _dylib.lookupFunction<_c_fuse_fs_create, _dart_fuse_fs_create>(
            'fuse_fs_create'))(
      fs,
      path,
      mode,
      fi,
    );
  }

  _dart_fuse_fs_create? _fuse_fs_create;

  int fuse_fs_lock(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
    int cmd,
    ffi.Pointer<flock> lock,
  ) {
    return (_fuse_fs_lock ??= _dylib
        .lookupFunction<_c_fuse_fs_lock, _dart_fuse_fs_lock>('fuse_fs_lock'))(
      fs,
      path,
      fi,
      cmd,
      lock,
    );
  }

  _dart_fuse_fs_lock? _fuse_fs_lock;

  int fuse_fs_flock(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
    int op,
  ) {
    return (_fuse_fs_flock ??=
        _dylib.lookupFunction<_c_fuse_fs_flock, _dart_fuse_fs_flock>(
            'fuse_fs_flock'))(
      fs,
      path,
      fi,
      op,
    );
  }

  _dart_fuse_fs_flock? _fuse_fs_flock;

  int fuse_fs_chmod(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mode,
  ) {
    return (_fuse_fs_chmod ??=
        _dylib.lookupFunction<_c_fuse_fs_chmod, _dart_fuse_fs_chmod>(
            'fuse_fs_chmod'))(
      fs,
      path,
      mode,
    );
  }

  _dart_fuse_fs_chmod? _fuse_fs_chmod;

  int fuse_fs_chown(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int uid,
    int gid,
  ) {
    return (_fuse_fs_chown ??=
        _dylib.lookupFunction<_c_fuse_fs_chown, _dart_fuse_fs_chown>(
            'fuse_fs_chown'))(
      fs,
      path,
      uid,
      gid,
    );
  }

  _dart_fuse_fs_chown? _fuse_fs_chown;

  int fuse_fs_truncate(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int size,
  ) {
    return (_fuse_fs_truncate ??=
        _dylib.lookupFunction<_c_fuse_fs_truncate, _dart_fuse_fs_truncate>(
            'fuse_fs_truncate'))(
      fs,
      path,
      size,
    );
  }

  _dart_fuse_fs_truncate? _fuse_fs_truncate;

  int fuse_fs_ftruncate(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int size,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_ftruncate ??=
        _dylib.lookupFunction<_c_fuse_fs_ftruncate, _dart_fuse_fs_ftruncate>(
            'fuse_fs_ftruncate'))(
      fs,
      path,
      size,
      fi,
    );
  }

  _dart_fuse_fs_ftruncate? _fuse_fs_ftruncate;

  int fuse_fs_utimens(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<timespec> tv,
  ) {
    return (_fuse_fs_utimens ??=
        _dylib.lookupFunction<_c_fuse_fs_utimens, _dart_fuse_fs_utimens>(
            'fuse_fs_utimens'))(
      fs,
      path,
      tv,
    );
  }

  _dart_fuse_fs_utimens? _fuse_fs_utimens;

  int fuse_fs_access(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mask,
  ) {
    return (_fuse_fs_access ??=
        _dylib.lookupFunction<_c_fuse_fs_access, _dart_fuse_fs_access>(
            'fuse_fs_access'))(
      fs,
      path,
      mask,
    );
  }

  _dart_fuse_fs_access? _fuse_fs_access;

  int fuse_fs_readlink(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> buf,
    int len,
  ) {
    return (_fuse_fs_readlink ??=
        _dylib.lookupFunction<_c_fuse_fs_readlink, _dart_fuse_fs_readlink>(
            'fuse_fs_readlink'))(
      fs,
      path,
      buf,
      len,
    );
  }

  _dart_fuse_fs_readlink? _fuse_fs_readlink;

  int fuse_fs_mknod(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    int rdev,
  ) {
    return (_fuse_fs_mknod ??=
        _dylib.lookupFunction<_c_fuse_fs_mknod, _dart_fuse_fs_mknod>(
            'fuse_fs_mknod'))(
      fs,
      path,
      mode,
      rdev,
    );
  }

  _dart_fuse_fs_mknod? _fuse_fs_mknod;

  int fuse_fs_mkdir(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mode,
  ) {
    return (_fuse_fs_mkdir ??=
        _dylib.lookupFunction<_c_fuse_fs_mkdir, _dart_fuse_fs_mkdir>(
            'fuse_fs_mkdir'))(
      fs,
      path,
      mode,
    );
  }

  _dart_fuse_fs_mkdir? _fuse_fs_mkdir;

  int fuse_fs_setxattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int size,
    int flags,
  ) {
    return (_fuse_fs_setxattr ??=
        _dylib.lookupFunction<_c_fuse_fs_setxattr, _dart_fuse_fs_setxattr>(
            'fuse_fs_setxattr'))(
      fs,
      path,
      name,
      value,
      size,
      flags,
    );
  }

  _dart_fuse_fs_setxattr? _fuse_fs_setxattr;

  int fuse_fs_getxattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
    int size,
  ) {
    return (_fuse_fs_getxattr ??=
        _dylib.lookupFunction<_c_fuse_fs_getxattr, _dart_fuse_fs_getxattr>(
            'fuse_fs_getxattr'))(
      fs,
      path,
      name,
      value,
      size,
    );
  }

  _dart_fuse_fs_getxattr? _fuse_fs_getxattr;

  int fuse_fs_listxattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> list,
    int size,
  ) {
    return (_fuse_fs_listxattr ??=
        _dylib.lookupFunction<_c_fuse_fs_listxattr, _dart_fuse_fs_listxattr>(
            'fuse_fs_listxattr'))(
      fs,
      path,
      list,
      size,
    );
  }

  _dart_fuse_fs_listxattr? _fuse_fs_listxattr;

  int fuse_fs_removexattr(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return (_fuse_fs_removexattr ??= _dylib.lookupFunction<
        _c_fuse_fs_removexattr,
        _dart_fuse_fs_removexattr>('fuse_fs_removexattr'))(
      fs,
      path,
      name,
    );
  }

  _dart_fuse_fs_removexattr? _fuse_fs_removexattr;

  int fuse_fs_bmap(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int blocksize,
    ffi.Pointer<ffi.Uint64> idx,
  ) {
    return (_fuse_fs_bmap ??= _dylib
        .lookupFunction<_c_fuse_fs_bmap, _dart_fuse_fs_bmap>('fuse_fs_bmap'))(
      fs,
      path,
      blocksize,
      idx,
    );
  }

  _dart_fuse_fs_bmap? _fuse_fs_bmap;

  int fuse_fs_ioctl(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int cmd,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<fuse_file_info> fi,
    int flags,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_fuse_fs_ioctl ??=
        _dylib.lookupFunction<_c_fuse_fs_ioctl, _dart_fuse_fs_ioctl>(
            'fuse_fs_ioctl'))(
      fs,
      path,
      cmd,
      arg,
      fi,
      flags,
      data,
    );
  }

  _dart_fuse_fs_ioctl? _fuse_fs_ioctl;

  int fuse_fs_poll(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<fuse_file_info> fi,
    ffi.Pointer<fuse_pollhandle> ph,
    ffi.Pointer<ffi.Uint32> reventsp,
  ) {
    return (_fuse_fs_poll ??= _dylib
        .lookupFunction<_c_fuse_fs_poll, _dart_fuse_fs_poll>('fuse_fs_poll'))(
      fs,
      path,
      fi,
      ph,
      reventsp,
    );
  }

  _dart_fuse_fs_poll? _fuse_fs_poll;

  int fuse_fs_fallocate(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    int offset,
    int length,
    ffi.Pointer<fuse_file_info> fi,
  ) {
    return (_fuse_fs_fallocate ??=
        _dylib.lookupFunction<_c_fuse_fs_fallocate, _dart_fuse_fs_fallocate>(
            'fuse_fs_fallocate'))(
      fs,
      path,
      mode,
      offset,
      length,
      fi,
    );
  }

  _dart_fuse_fs_fallocate? _fuse_fs_fallocate;

  void fuse_fs_init(
    ffi.Pointer<fuse_fs> fs,
    ffi.Pointer<fuse_conn_info> conn,
  ) {
    return (_fuse_fs_init ??= _dylib
        .lookupFunction<_c_fuse_fs_init, _dart_fuse_fs_init>('fuse_fs_init'))(
      fs,
      conn,
    );
  }

  _dart_fuse_fs_init? _fuse_fs_init;

  void fuse_fs_destroy(
    ffi.Pointer<fuse_fs> fs,
  ) {
    return (_fuse_fs_destroy ??=
        _dylib.lookupFunction<_c_fuse_fs_destroy, _dart_fuse_fs_destroy>(
            'fuse_fs_destroy'))(
      fs,
    );
  }

  _dart_fuse_fs_destroy? _fuse_fs_destroy;

  int fuse_notify_poll(
    ffi.Pointer<fuse_pollhandle> ph,
  ) {
    return (_fuse_notify_poll ??=
        _dylib.lookupFunction<_c_fuse_notify_poll, _dart_fuse_notify_poll>(
            'fuse_notify_poll'))(
      ph,
    );
  }

  _dart_fuse_notify_poll? _fuse_notify_poll;

  /// Create a new fuse filesystem object
  ///
  /// This is usually called from the factory of a fuse module to create
  /// a new instance of a filesystem.
  ///
  /// @param op the filesystem operations
  /// @param op_size the size of the fuse_operations structure
  /// @param user_data user data supplied in the context during the init() method
  /// @return a new filesystem object
  ffi.Pointer<fuse_fs> fuse_fs_new(
    ffi.Pointer<fuse_operations> op,
    int op_size,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return (_fuse_fs_new ??= _dylib
        .lookupFunction<_c_fuse_fs_new, _dart_fuse_fs_new>('fuse_fs_new'))(
      op,
      op_size,
      user_data,
    );
  }

  _dart_fuse_fs_new? _fuse_fs_new;

  /// Register a filesystem module
  ///
  /// This function is used by FUSE_REGISTER_MODULE and there's usually
  /// no need to call it directly
  void fuse_register_module(
    ffi.Pointer<fuse_module> mod,
  ) {
    return (_fuse_register_module ??= _dylib.lookupFunction<
        _c_fuse_register_module,
        _dart_fuse_register_module>('fuse_register_module'))(
      mod,
    );
  }

  _dart_fuse_register_module? _fuse_register_module;

  /// This is the part of fuse_main() before the event loop
  ffi.Pointer<fuse> fuse_setup(
    int argc,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
    ffi.Pointer<fuse_operations> op,
    int op_size,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
    ffi.Pointer<ffi.Int32> multithreaded,
    ffi.Pointer<ffi.Void> user_data,
  ) {
    return (_fuse_setup ??=
        _dylib.lookupFunction<_c_fuse_setup, _dart_fuse_setup>('fuse_setup'))(
      argc,
      argv,
      op,
      op_size,
      mountpoint,
      multithreaded,
      user_data,
    );
  }

  _dart_fuse_setup? _fuse_setup;

  /// This is the part of fuse_main() after the event loop
  void fuse_teardown(
    ffi.Pointer<fuse> fuse,
    ffi.Pointer<ffi.Int8> mountpoint,
  ) {
    return (_fuse_teardown ??=
        _dylib.lookupFunction<_c_fuse_teardown, _dart_fuse_teardown>(
            'fuse_teardown'))(
      fuse,
      mountpoint,
    );
  }

  _dart_fuse_teardown? _fuse_teardown;

  /// Read a single command.  If none are read, return NULL
  ffi.Pointer<fuse_cmd> fuse_read_cmd(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_read_cmd ??=
        _dylib.lookupFunction<_c_fuse_read_cmd, _dart_fuse_read_cmd>(
            'fuse_read_cmd'))(
      f,
    );
  }

  _dart_fuse_read_cmd? _fuse_read_cmd;

  /// Process a single command
  void fuse_process_cmd(
    ffi.Pointer<fuse> f,
    ffi.Pointer<fuse_cmd> cmd,
  ) {
    return (_fuse_process_cmd ??=
        _dylib.lookupFunction<_c_fuse_process_cmd, _dart_fuse_process_cmd>(
            'fuse_process_cmd'))(
      f,
      cmd,
    );
  }

  _dart_fuse_process_cmd? _fuse_process_cmd;

  /// Multi threaded event loop, which calls the custom command
  /// processor function
  int fuse_loop_mt_proc(
    ffi.Pointer<fuse> f,
    ffi.Pointer<ffi.NativeFunction<fuse_processor_t>> proc,
    ffi.Pointer<ffi.Void> data,
  ) {
    return (_fuse_loop_mt_proc ??=
        _dylib.lookupFunction<_c_fuse_loop_mt_proc, _dart_fuse_loop_mt_proc>(
            'fuse_loop_mt_proc'))(
      f,
      proc,
      data,
    );
  }

  _dart_fuse_loop_mt_proc? _fuse_loop_mt_proc;

  /// Return the exited flag, which indicates if fuse_exit() has been
  /// called
  int fuse_exited(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_exited ??= _dylib
        .lookupFunction<_c_fuse_exited, _dart_fuse_exited>('fuse_exited'))(
      f,
    );
  }

  _dart_fuse_exited? _fuse_exited;

  /// Get session from fuse object
  ffi.Pointer<fuse_session> fuse_get_session(
    ffi.Pointer<fuse> f,
  ) {
    return (_fuse_get_session ??=
        _dylib.lookupFunction<_c_fuse_get_session, _dart_fuse_get_session>(
            'fuse_get_session'))(
      f,
    );
  }

  _dart_fuse_get_session? _fuse_get_session;
}

/// Information about open files
///
/// Changed in version 2.5
class fuse_file_info extends ffi.Struct {}

/// Connection information, passed to the ->init() method
///
/// Some of the elements are read-write, these can be changed to
/// indicate the value requested by the filesystem.  The requested
/// value must usually be smaller than the indicated value.
class fuse_conn_info extends ffi.Struct {
  /// Major version of the protocol (read-only)
  @ffi.Uint32()
  external int proto_major;

  /// Minor version of the protocol (read-only)
  @ffi.Uint32()
  external int proto_minor;

  /// Is asynchronous read supported (read-write)
  @ffi.Uint32()
  external int async_read;

  /// Maximum size of the write buffer
  @ffi.Uint32()
  external int max_write;

  /// Maximum readahead
  @ffi.Uint32()
  external int max_readahead;

  /// Capability flags, that the kernel supports
  @ffi.Uint32()
  external int capable;

  /// Capability flags, that the filesystem wants to enable
  @ffi.Uint32()
  external int want;

  /// Maximum number of backgrounded requests
  @ffi.Uint32()
  external int max_background;

  /// Kernel congestion threshold parameter
  @ffi.Uint32()
  external int congestion_threshold;

  @ffi.Uint32()
  external int _unique_reserved_item_0;
  @ffi.Uint32()
  external int _unique_reserved_item_1;
  @ffi.Uint32()
  external int _unique_reserved_item_2;
  @ffi.Uint32()
  external int _unique_reserved_item_3;
  @ffi.Uint32()
  external int _unique_reserved_item_4;
  @ffi.Uint32()
  external int _unique_reserved_item_5;
  @ffi.Uint32()
  external int _unique_reserved_item_6;
  @ffi.Uint32()
  external int _unique_reserved_item_7;
  @ffi.Uint32()
  external int _unique_reserved_item_8;
  @ffi.Uint32()
  external int _unique_reserved_item_9;
  @ffi.Uint32()
  external int _unique_reserved_item_10;
  @ffi.Uint32()
  external int _unique_reserved_item_11;
  @ffi.Uint32()
  external int _unique_reserved_item_12;
  @ffi.Uint32()
  external int _unique_reserved_item_13;
  @ffi.Uint32()
  external int _unique_reserved_item_14;
  @ffi.Uint32()
  external int _unique_reserved_item_15;
  @ffi.Uint32()
  external int _unique_reserved_item_16;
  @ffi.Uint32()
  external int _unique_reserved_item_17;
  @ffi.Uint32()
  external int _unique_reserved_item_18;
  @ffi.Uint32()
  external int _unique_reserved_item_19;
  @ffi.Uint32()
  external int _unique_reserved_item_20;
  @ffi.Uint32()
  external int _unique_reserved_item_21;
  @ffi.Uint32()
  external int _unique_reserved_item_22;

  /// Helper for array `reserved`.
  ArrayHelper_fuse_conn_info_reserved_level0 get reserved =>
      ArrayHelper_fuse_conn_info_reserved_level0(this, [23], 0, 0);
}

/// Helper for array `reserved` in struct `fuse_conn_info`.
class ArrayHelper_fuse_conn_info_reserved_level0 {
  final fuse_conn_info _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_fuse_conn_info_reserved_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_reserved_item_0;
      case 1:
        return _struct._unique_reserved_item_1;
      case 2:
        return _struct._unique_reserved_item_2;
      case 3:
        return _struct._unique_reserved_item_3;
      case 4:
        return _struct._unique_reserved_item_4;
      case 5:
        return _struct._unique_reserved_item_5;
      case 6:
        return _struct._unique_reserved_item_6;
      case 7:
        return _struct._unique_reserved_item_7;
      case 8:
        return _struct._unique_reserved_item_8;
      case 9:
        return _struct._unique_reserved_item_9;
      case 10:
        return _struct._unique_reserved_item_10;
      case 11:
        return _struct._unique_reserved_item_11;
      case 12:
        return _struct._unique_reserved_item_12;
      case 13:
        return _struct._unique_reserved_item_13;
      case 14:
        return _struct._unique_reserved_item_14;
      case 15:
        return _struct._unique_reserved_item_15;
      case 16:
        return _struct._unique_reserved_item_16;
      case 17:
        return _struct._unique_reserved_item_17;
      case 18:
        return _struct._unique_reserved_item_18;
      case 19:
        return _struct._unique_reserved_item_19;
      case 20:
        return _struct._unique_reserved_item_20;
      case 21:
        return _struct._unique_reserved_item_21;
      case 22:
        return _struct._unique_reserved_item_22;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_reserved_item_0 = value;
        break;
      case 1:
        _struct._unique_reserved_item_1 = value;
        break;
      case 2:
        _struct._unique_reserved_item_2 = value;
        break;
      case 3:
        _struct._unique_reserved_item_3 = value;
        break;
      case 4:
        _struct._unique_reserved_item_4 = value;
        break;
      case 5:
        _struct._unique_reserved_item_5 = value;
        break;
      case 6:
        _struct._unique_reserved_item_6 = value;
        break;
      case 7:
        _struct._unique_reserved_item_7 = value;
        break;
      case 8:
        _struct._unique_reserved_item_8 = value;
        break;
      case 9:
        _struct._unique_reserved_item_9 = value;
        break;
      case 10:
        _struct._unique_reserved_item_10 = value;
        break;
      case 11:
        _struct._unique_reserved_item_11 = value;
        break;
      case 12:
        _struct._unique_reserved_item_12 = value;
        break;
      case 13:
        _struct._unique_reserved_item_13 = value;
        break;
      case 14:
        _struct._unique_reserved_item_14 = value;
        break;
      case 15:
        _struct._unique_reserved_item_15 = value;
        break;
      case 16:
        _struct._unique_reserved_item_16 = value;
        break;
      case 17:
        _struct._unique_reserved_item_17 = value;
        break;
      case 18:
        _struct._unique_reserved_item_18 = value;
        break;
      case 19:
        _struct._unique_reserved_item_19 = value;
        break;
      case 20:
        _struct._unique_reserved_item_20 = value;
        break;
      case 21:
        _struct._unique_reserved_item_21 = value;
        break;
      case 22:
        _struct._unique_reserved_item_22 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class fuse_session extends ffi.Struct {}

class fuse_chan extends ffi.Struct {}

class fuse_pollhandle extends ffi.Struct {}

/// Argument list
class fuse_args extends ffi.Struct {
  /// Argument count
  @ffi.Int32()
  external int argc;

  /// Argument vector.  NULL terminated
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> argv;

  /// Is 'argv' allocated?
  @ffi.Int32()
  external int allocated;
}

/// Buffer flags
abstract class fuse_buf_flags {
  /// Buffer contains a file descriptor
  ///
  /// If this flag is set, the .fd field is valid, otherwise the
  /// .mem fields is valid.
  static const int FUSE_BUF_IS_FD = 2;

  /// Seek on the file descriptor
  ///
  /// If this flag is set then the .pos field is valid and is
  /// used to seek to the given offset before performing
  /// operation on file descriptor.
  static const int FUSE_BUF_FD_SEEK = 4;

  /// Retry operation on file descriptor
  ///
  /// If this flag is set then retry operation on file descriptor
  /// until .size bytes have been copied or an error or EOF is
  /// detected.
  static const int FUSE_BUF_FD_RETRY = 8;
}

/// Buffer copy flags
abstract class fuse_buf_copy_flags {
  /// Don't use splice(2)
  ///
  /// Always fall back to using read and write instead of
  /// splice(2) to copy data from one file descriptor to another.
  ///
  /// If this flag is not set, then only fall back if splice is
  /// unavailable.
  static const int FUSE_BUF_NO_SPLICE = 2;

  /// Force splice
  ///
  /// Always use splice(2) to copy data from one file descriptor
  /// to another.  If splice is not available, return -EINVAL.
  static const int FUSE_BUF_FORCE_SPLICE = 4;

  /// Try to move data with splice.
  ///
  /// If splice is used, try to move pages from the source to the
  /// destination instead of copying.  See documentation of
  /// SPLICE_F_MOVE in splice(2) man page.
  static const int FUSE_BUF_SPLICE_MOVE = 8;

  /// Don't block on the pipe when copying data with splice
  ///
  /// Makes the operations on the pipe non-blocking (if the pipe
  /// is full or empty).  See SPLICE_F_NONBLOCK in the splice(2)
  /// man page.
  static const int FUSE_BUF_SPLICE_NONBLOCK = 16;
}

/// Single data buffer
///
/// Generic data buffer for I/O, extended attributes, etc...  Data may
/// be supplied as a memory pointer or as a file descriptor
class fuse_buf extends ffi.Struct {
  /// Size of data in bytes
  @ffi.Int32()
  external int size;

  /// Buffer flags
  @ffi.Int32()
  external int flags;

  /// Memory pointer
  ///
  /// Used unless FUSE_BUF_IS_FD flag is set.
  external ffi.Pointer<ffi.Void> mem;

  /// File descriptor
  ///
  /// Used if FUSE_BUF_IS_FD flag is set.
  @ffi.Int32()
  external int fd;

  /// File position
  ///
  /// Used if FUSE_BUF_FD_SEEK flag is set.
  @ffi.Int64()
  external int pos;
}

/// Data buffer vector
///
/// An array of data buffers, each containing a memory pointer or a
/// file descriptor.
///
/// Allocate dynamically to add more than one buffer.
class fuse_bufvec extends ffi.Struct {
  /// Number of buffers in the array
  @ffi.Int32()
  external int count;

  /// Index of current buffer within the array
  @ffi.Int32()
  external int idx;

  /// Current offset within the current buffer
  @ffi.Int32()
  external int off;

  external fuse_buf _unique_buf_item_0;

  /// Helper for array `buf`.
  ArrayHelper_fuse_bufvec_buf_level0 get buf =>
      ArrayHelper_fuse_bufvec_buf_level0(this, [1], 0, 0);
}

/// Helper for array `buf` in struct `fuse_bufvec`.
class ArrayHelper_fuse_bufvec_buf_level0 {
  final fuse_bufvec _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_fuse_bufvec_buf_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  fuse_buf operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_buf_item_0;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, fuse_buf value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_buf_item_0 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Handle for a FUSE filesystem
class fuse extends ffi.Struct {}

/// Structure containing a raw command
class fuse_cmd extends ffi.Struct {}

class fuse_dirhandle extends ffi.Struct {}

class timespec extends ffi.Struct {
  @ffi.Int64()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

class stat extends ffi.Struct {
  @ffi.Uint64()
  external int st_dev;

  @ffi.Uint64()
  external int st_ino;

  @ffi.Uint64()
  external int st_nlink;

  @ffi.Uint32()
  external int st_mode;

  @ffi.Uint32()
  external int st_uid;

  @ffi.Uint32()
  external int st_gid;

  @ffi.Int32()
  external int __pad0;

  @ffi.Uint64()
  external int st_rdev;

  @ffi.Int64()
  external int st_size;

  @ffi.Int64()
  external int st_blksize;

  @ffi.Int64()
  external int st_blocks;

  external timespec st_atim;

  external timespec st_mtim;

  external timespec st_ctim;

  @ffi.Int64()
  external int _unique___glibc_reserved_item_0;
  @ffi.Int64()
  external int _unique___glibc_reserved_item_1;
  @ffi.Int64()
  external int _unique___glibc_reserved_item_2;

  /// Helper for array `__glibc_reserved`.
  ArrayHelper_stat___glibc_reserved_level0 get __glibc_reserved =>
      ArrayHelper_stat___glibc_reserved_level0(this, [3], 0, 0);
}

/// Helper for array `__glibc_reserved` in struct `stat`.
class ArrayHelper_stat___glibc_reserved_level0 {
  final stat _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_stat___glibc_reserved_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___glibc_reserved_item_0;
      case 1:
        return _struct._unique___glibc_reserved_item_1;
      case 2:
        return _struct._unique___glibc_reserved_item_2;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___glibc_reserved_item_0 = value;
        break;
      case 1:
        _struct._unique___glibc_reserved_item_1 = value;
        break;
      case 2:
        _struct._unique___glibc_reserved_item_2 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class utimbuf extends ffi.Struct {
  @ffi.Int64()
  external int actime;

  @ffi.Int64()
  external int modtime;
}

class statvfs extends ffi.Struct {
  @ffi.Uint64()
  external int f_bsize;

  @ffi.Uint64()
  external int f_frsize;

  @ffi.Uint64()
  external int f_blocks;

  @ffi.Uint64()
  external int f_bfree;

  @ffi.Uint64()
  external int f_bavail;

  @ffi.Uint64()
  external int f_files;

  @ffi.Uint64()
  external int f_ffree;

  @ffi.Uint64()
  external int f_favail;

  @ffi.Uint64()
  external int f_fsid;

  @ffi.Uint64()
  external int f_flag;

  @ffi.Uint64()
  external int f_namemax;

  @ffi.Int32()
  external int _unique___f_spare_item_0;
  @ffi.Int32()
  external int _unique___f_spare_item_1;
  @ffi.Int32()
  external int _unique___f_spare_item_2;
  @ffi.Int32()
  external int _unique___f_spare_item_3;
  @ffi.Int32()
  external int _unique___f_spare_item_4;
  @ffi.Int32()
  external int _unique___f_spare_item_5;

  /// Helper for array `__f_spare`.
  ArrayHelper_statvfs___f_spare_level0 get __f_spare =>
      ArrayHelper_statvfs___f_spare_level0(this, [6], 0, 0);
}

/// Helper for array `__f_spare` in struct `statvfs`.
class ArrayHelper_statvfs___f_spare_level0 {
  final statvfs _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_statvfs___f_spare_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___f_spare_item_0;
      case 1:
        return _struct._unique___f_spare_item_1;
      case 2:
        return _struct._unique___f_spare_item_2;
      case 3:
        return _struct._unique___f_spare_item_3;
      case 4:
        return _struct._unique___f_spare_item_4;
      case 5:
        return _struct._unique___f_spare_item_5;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___f_spare_item_0 = value;
        break;
      case 1:
        _struct._unique___f_spare_item_1 = value;
        break;
      case 2:
        _struct._unique___f_spare_item_2 = value;
        break;
      case 3:
        _struct._unique___f_spare_item_3 = value;
        break;
      case 4:
        _struct._unique___f_spare_item_4 = value;
        break;
      case 5:
        _struct._unique___f_spare_item_5 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class flock extends ffi.Struct {
  @ffi.Int16()
  external int l_type;

  @ffi.Int16()
  external int l_whence;

  @ffi.Int64()
  external int l_start;

  @ffi.Int64()
  external int l_len;

  @ffi.Int32()
  external int l_pid;
}

/// The file system operations:
///
/// Most of these should work very similarly to the well known UNIX
/// file system operations.  A major exception is that instead of
/// returning an error in 'errno', the operation should return the
/// negated error value (-errno) directly.
///
/// All methods are optional, but some are essential for a useful
/// filesystem (e.g. getattr).  Open, flush, release, fsync, opendir,
/// releasedir, fsyncdir, access, create, ftruncate, fgetattr, lock,
/// init and destroy are special purpose methods, without which a full
/// featured filesystem can still be implemented.
///
/// Almost all operations take a path which can be of any length.
///
/// Changed in fuse 2.8.0 (regardless of API version)
/// Previously, paths were limited to a length of PATH_MAX.
///
/// See http://fuse.sourceforge.net/wiki/ for more information.  There
/// is also a snapshot of the relevant wiki pages in the doc/ folder.
class fuse_operations extends ffi.Struct {
  /// Get file attributes.
  ///
  /// Similar to stat().  The 'st_dev' and 'st_blksize' fields are
  /// ignored.	 The 'st_ino' field is ignored except if the 'use_ino'
  /// mount option is given.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_1>> getattr;

  /// Read the target of a symbolic link
  ///
  /// The buffer should be filled with a null terminated string.  The
  /// buffer size argument includes the space for the terminating
  /// null character.	If the linkname is too long to fit in the
  /// buffer, it should be truncated.	The return value should be 0
  /// for success.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_2>> readlink;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_3>> getdir;

  /// Create a file node
  ///
  /// This is called for creation of all non-directory, non-symlink
  /// nodes.  If the filesystem defines a create() method, then for
  /// regular files that will be called instead.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> mknod;

  /// Create a directory
  ///
  /// Note that the mode argument may not have the type specification
  /// bits set, i.e. S_ISDIR(mode) can be false.  To obtain the
  /// correct directory type bits use  mode|S_IFDIR
  external ffi.Pointer<ffi.NativeFunction<_typedefC_5>> mkdir;

  /// Remove a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_6>> unlink;

  /// Remove a directory
  external ffi.Pointer<ffi.NativeFunction<_typedefC_7>> rmdir;

  /// Create a symbolic link
  external ffi.Pointer<ffi.NativeFunction<_typedefC_8>> symlink;

  /// Rename a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_9>> rename;

  /// Create a hard link to a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_10>> link;

  /// Change the permission bits of a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_11>> chmod;

  /// Change the owner and group of a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_12>> chown;

  /// Change the size of a file
  external ffi.Pointer<ffi.NativeFunction<_typedefC_13>> truncate;

  /// Change the access and/or modification times of a file
  ///
  /// Deprecated, use utimens() instead.
  external ffi.Pointer<ffi.NativeFunction<_typedefC_14>> utime;

  /// File open operation
  ///
  /// No creation (O_CREAT, O_EXCL) and by default also no
  /// truncation (O_TRUNC) flags will be passed to open(). If an
  /// application specifies O_TRUNC, fuse first calls truncate()
  /// and then open(). Only if 'atomic_o_trunc' has been
  /// specified and kernel version is 2.6.24 or later, O_TRUNC is
  /// passed on to open.
  ///
  /// Unless the 'default_permissions' mount option is given,
  /// open should check if the operation is permitted for the
  /// given flags. Optionally open may also return an arbitrary
  /// filehandle in the fuse_file_info structure, which will be
  /// passed to all file operations.
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_15>> open;

  /// Read data from an open file
  ///
  /// Read should return exactly the number of bytes requested except
  /// on EOF or error, otherwise the rest of the data will be
  /// substituted with zeroes.	 An exception to this is when the
  /// 'direct_io' mount option is specified, in which case the return
  /// value of the read system call will reflect the return value of
  /// this operation.
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_16>> read;

  /// Write data to an open file
  ///
  /// Write should return exactly the number of bytes requested
  /// except on error.	 An exception to this is when the 'direct_io'
  /// mount option is specified (see read operation).
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_17>> write;

  /// Get file system statistics
  ///
  /// The 'f_frsize', 'f_favail', 'f_fsid' and 'f_flag' fields are ignored
  ///
  /// Replaced 'struct statfs' parameter with 'struct statvfs' in
  /// version 2.5
  external ffi.Pointer<ffi.NativeFunction<_typedefC_18>> statfs;

  /// Possibly flush cached data
  ///
  /// BIG NOTE: This is not equivalent to fsync().  It's not a
  /// request to sync dirty data.
  ///
  /// Flush is called on each close() of a file descriptor.  So if a
  /// filesystem wants to return write errors in close() and the file
  /// has cached dirty data, this is a good place to write back data
  /// and return any errors.  Since many applications ignore close()
  /// errors this is not always useful.
  ///
  /// NOTE: The flush() method may be called more than once for each
  /// open().	This happens if more than one file descriptor refers
  /// to an opened file due to dup(), dup2() or fork() calls.	It is
  /// not possible to determine if a flush is final, so each flush
  /// should be treated equally.  Multiple write-flush sequences are
  /// relatively rare, so this shouldn't be a problem.
  ///
  /// Filesystems shouldn't assume that flush will always be called
  /// after some writes, or that if will be called at all.
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_19>> flush;

  /// Release an open file
  ///
  /// Release is called when there are no more references to an open
  /// file: all file descriptors are closed and all memory mappings
  /// are unmapped.
  ///
  /// For every open() call there will be exactly one release() call
  /// with the same flags and file descriptor.	 It is possible to
  /// have a file opened more than once, in which case only the last
  /// release will mean, that no more reads/writes will happen on the
  /// file.  The return value of release is ignored.
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_20>> release;

  /// Synchronize file contents
  ///
  /// If the datasync parameter is non-zero, then only the user data
  /// should be flushed, not the meta data.
  ///
  /// Changed in version 2.2
  external ffi.Pointer<ffi.NativeFunction<_typedefC_21>> fsync;

  /// Set extended attributes
  external ffi.Pointer<ffi.NativeFunction<_typedefC_22>> setxattr;

  /// Get extended attributes
  external ffi.Pointer<ffi.NativeFunction<_typedefC_23>> getxattr;

  /// List extended attributes
  external ffi.Pointer<ffi.NativeFunction<_typedefC_24>> listxattr;

  /// Remove extended attributes
  external ffi.Pointer<ffi.NativeFunction<_typedefC_25>> removexattr;

  /// Open directory
  ///
  /// Unless the 'default_permissions' mount option is given,
  /// this method should check if opendir is permitted for this
  /// directory. Optionally opendir may also return an arbitrary
  /// filehandle in the fuse_file_info structure, which will be
  /// passed to readdir, releasedir and fsyncdir.
  ///
  /// Introduced in version 2.3
  external ffi.Pointer<ffi.NativeFunction<_typedefC_26>> opendir;

  /// Read directory
  ///
  /// This supersedes the old getdir() interface.  New applications
  /// should use this.
  ///
  /// The filesystem may choose between two modes of operation:
  ///
  /// 1) The readdir implementation ignores the offset parameter, and
  /// passes zero to the filler function's offset.  The filler
  /// function will not return '1' (unless an error happens), so the
  /// whole directory is read in a single readdir operation.  This
  /// works just like the old getdir() method.
  ///
  /// 2) The readdir implementation keeps track of the offsets of the
  /// directory entries.  It uses the offset parameter and always
  /// passes non-zero offset to the filler function.  When the buffer
  /// is full (or an error happens) the filler function will return
  /// '1'.
  ///
  /// Introduced in version 2.3
  external ffi.Pointer<ffi.NativeFunction<_typedefC_27>> readdir;

  /// Release directory
  ///
  /// Introduced in version 2.3
  external ffi.Pointer<ffi.NativeFunction<_typedefC_28>> releasedir;

  /// Synchronize directory contents
  ///
  /// If the datasync parameter is non-zero, then only the user data
  /// should be flushed, not the meta data
  ///
  /// Introduced in version 2.3
  external ffi.Pointer<ffi.NativeFunction<_typedefC_29>> fsyncdir;

  /// Initialize filesystem
  ///
  /// The return value will passed in the private_data field of
  /// fuse_context to all file operations and as a parameter to the
  /// destroy() method.
  ///
  /// Introduced in version 2.3
  /// Changed in version 2.6
  external ffi.Pointer<ffi.NativeFunction<_typedefC_30>> init;

  /// Clean up filesystem
  ///
  /// Called on filesystem exit.
  ///
  /// Introduced in version 2.3
  external ffi.Pointer<ffi.NativeFunction<_typedefC_31>> destroy;

  /// Check file access permissions
  ///
  /// This will be called for the access() system call.  If the
  /// 'default_permissions' mount option is given, this method is not
  /// called.
  ///
  /// This method is not called under Linux kernel versions 2.4.x
  ///
  /// Introduced in version 2.5
  external ffi.Pointer<ffi.NativeFunction<_typedefC_32>> access;

  /// Create and open a file
  ///
  /// If the file does not exist, first create it with the specified
  /// mode, and then open it.
  ///
  /// If this method is not implemented or under Linux kernel
  /// versions earlier than 2.6.15, the mknod() and open() methods
  /// will be called instead.
  ///
  /// Introduced in version 2.5
  external ffi.Pointer<ffi.NativeFunction<_typedefC_33>> create;

  /// Change the size of an open file
  ///
  /// This method is called instead of the truncate() method if the
  /// truncation was invoked from an ftruncate() system call.
  ///
  /// If this method is not implemented or under Linux kernel
  /// versions earlier than 2.6.15, the truncate() method will be
  /// called instead.
  ///
  /// Introduced in version 2.5
  external ffi.Pointer<ffi.NativeFunction<_typedefC_34>> ftruncate;

  /// Get attributes from an open file
  ///
  /// This method is called instead of the getattr() method if the
  /// file information is available.
  ///
  /// Currently this is only called after the create() method if that
  /// is implemented (see above).  Later it may be called for
  /// invocations of fstat() too.
  ///
  /// Introduced in version 2.5
  external ffi.Pointer<ffi.NativeFunction<_typedefC_35>> fgetattr;

  /// Perform POSIX file locking operation
  ///
  /// The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.
  ///
  /// For the meaning of fields in 'struct flock' see the man page
  /// for fcntl(2).  The l_whence field will always be set to
  /// SEEK_SET.
  ///
  /// For checking lock ownership, the 'fuse_file_info->owner'
  /// argument must be used.
  ///
  /// For F_GETLK operation, the library will first check currently
  /// held locks, and if a conflicting lock is found it will return
  /// information without calling this method.	 This ensures, that
  /// for local locks the l_pid field is correctly filled in.	The
  /// results may not be accurate in case of race conditions and in
  /// the presence of hard links, but it's unlikely that an
  /// application would rely on accurate GETLK results in these
  /// cases.  If a conflicting lock is not found, this method will be
  /// called, and the filesystem may fill out l_pid by a meaningful
  /// value, or it may leave this field zero.
  ///
  /// For F_SETLK and F_SETLKW the l_pid field will be set to the pid
  /// of the process performing the locking operation.
  ///
  /// Note: if this method is not implemented, the kernel will still
  /// allow file locking to work locally.  Hence it is only
  /// interesting for network filesystems and similar.
  ///
  /// Introduced in version 2.6
  external ffi.Pointer<ffi.NativeFunction<_typedefC_36>> lock;

  /// Change the access and modification times of a file with
  /// nanosecond resolution
  ///
  /// This supersedes the old utime() interface.  New applications
  /// should use this.
  ///
  /// See the utimensat(2) man page for details.
  ///
  /// Introduced in version 2.6
  external ffi.Pointer<ffi.NativeFunction<_typedefC_37>> utimens;

  /// Map block index within file to block index within device
  ///
  /// Note: This makes sense only for block device backed filesystems
  /// mounted with the 'blkdev' option
  ///
  /// Introduced in version 2.6
  external ffi.Pointer<ffi.NativeFunction<_typedefC_38>> bmap;

  /// Ioctl
  ///
  /// flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in
  /// 64bit environment.  The size and direction of data is
  /// determined by _IOC_*() decoding of cmd.  For _IOC_NONE,
  /// data will be NULL, for _IOC_WRITE data is out area, for
  /// _IOC_READ in area and if both are set in/out area.  In all
  /// non-NULL cases, the area is of _IOC_SIZE(cmd) bytes.
  ///
  /// If flags has FUSE_IOCTL_DIR then the fuse_file_info refers to a
  /// directory file handle.
  ///
  /// Introduced in version 2.8
  external ffi.Pointer<ffi.NativeFunction<_typedefC_39>> ioctl;

  /// Poll for IO readiness events
  ///
  /// Note: If ph is non-NULL, the client should notify
  /// when IO readiness events occur by calling
  /// fuse_notify_poll() with the specified ph.
  ///
  /// Regardless of the number of times poll with a non-NULL ph
  /// is received, single notification is enough to clear all.
  /// Notifying more times incurs overhead but doesn't harm
  /// correctness.
  ///
  /// The callee is responsible for destroying ph with
  /// fuse_pollhandle_destroy() when no longer in use.
  ///
  /// Introduced in version 2.8
  external ffi.Pointer<ffi.NativeFunction<_typedefC_40>> poll;

  /// Write contents of buffer to an open file
  ///
  /// Similar to the write() method, but data is supplied in a
  /// generic buffer.  Use fuse_buf_copy() to transfer data to
  /// the destination.
  ///
  /// Introduced in version 2.9
  external ffi.Pointer<ffi.NativeFunction<_typedefC_41>> write_buf;

  /// Store data from an open file in a buffer
  ///
  /// Similar to the read() method, but data is stored and
  /// returned in a generic buffer.
  ///
  /// No actual copying of data has to take place, the source
  /// file descriptor may simply be stored in the buffer for
  /// later data transfer.
  ///
  /// The buffer must be allocated dynamically and stored at the
  /// location pointed to by bufp.  If the buffer contains memory
  /// regions, they too must be allocated using malloc().  The
  /// allocated memory will be freed by the caller.
  ///
  /// Introduced in version 2.9
  external ffi.Pointer<ffi.NativeFunction<_typedefC_42>> read_buf;

  /// Perform BSD file locking operation
  ///
  /// The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN
  ///
  /// Nonblocking requests will be indicated by ORing LOCK_NB to
  /// the above operations
  ///
  /// For more information see the flock(2) manual page.
  ///
  /// Additionally fi->owner will be set to a value unique to
  /// this open file.  This same value will be supplied to
  /// ->release() when the file is released.
  ///
  /// Note: if this method is not implemented, the kernel will still
  /// allow file locking to work locally.  Hence it is only
  /// interesting for network filesystems and similar.
  ///
  /// Introduced in version 2.9
  external ffi.Pointer<ffi.NativeFunction<_typedefC_43>> flock;

  /// Allocates space for an open file
  ///
  /// This function ensures that required space is allocated for specified
  /// file.  If this function returns success then any subsequent write
  /// request to specified range is guaranteed not to fail because of lack
  /// of space on the file system media.
  ///
  /// Introduced in version 2.9.1
  external ffi.Pointer<ffi.NativeFunction<_typedefC_44>> fallocate;
}

/// Fuse filesystem object
///
/// This is opaque object represents a filesystem layer
class fuse_fs extends ffi.Struct {}

class fusemod_so extends ffi.Struct {}

/// Filesystem module
///
/// Filesystem modules are registered with the FUSE_REGISTER_MODULE()
/// macro.
///
/// If the "-omodules=modname:..." option is present, filesystem
/// objects are created and pushed onto the stack with the 'factory'
/// function.
class fuse_module extends ffi.Struct {
  /// Name of filesystem
  external ffi.Pointer<ffi.Int8> name;

  /// Factory for creating filesystem objects
  ///
  /// The function may use and remove options from 'args' that belong
  /// to this module.
  ///
  /// For now the 'fs' vector always contains exactly one filesystem.
  /// This is the filesystem which will be below the newly created
  /// filesystem in the stack.
  ///
  /// @param args the command line arguments
  /// @param fs NULL terminated filesystem object vector
  /// @return the new filesystem object
  external ffi.Pointer<ffi.NativeFunction<_typedefC_45>> factory_1;

  external ffi.Pointer<fuse_module> next;

  external ffi.Pointer<fusemod_so> so;

  @ffi.Int32()
  external int ctr;
}

const int FUSE_USE_VERSION = 21;

const int FUSE_MAJOR_VERSION = 2;

const int FUSE_MINOR_VERSION = 1;

const int FUSE_VERSION = 21;

const int FUSE_CAP_ASYNC_READ = 1;

const int FUSE_CAP_POSIX_LOCKS = 2;

const int FUSE_CAP_ATOMIC_O_TRUNC = 8;

const int FUSE_CAP_EXPORT_SUPPORT = 16;

const int FUSE_CAP_BIG_WRITES = 32;

const int FUSE_CAP_DONT_MASK = 64;

const int FUSE_CAP_SPLICE_WRITE = 128;

const int FUSE_CAP_SPLICE_MOVE = 256;

const int FUSE_CAP_SPLICE_READ = 512;

const int FUSE_CAP_FLOCK_LOCKS = 1024;

const int FUSE_CAP_IOCTL_DIR = 2048;

const int FUSE_IOCTL_COMPAT = 1;

const int FUSE_IOCTL_UNRESTRICTED = 2;

const int FUSE_IOCTL_RETRY = 4;

const int FUSE_IOCTL_DIR = 16;

const int FUSE_IOCTL_MAX_IOV = 256;

typedef _c_fuse_mount = ffi.Pointer<fuse_chan> Function(
  ffi.Pointer<ffi.Int8> mountpoint,
  ffi.Pointer<fuse_args> args,
);

typedef _dart_fuse_mount = ffi.Pointer<fuse_chan> Function(
  ffi.Pointer<ffi.Int8> mountpoint,
  ffi.Pointer<fuse_args> args,
);

typedef _c_fuse_unmount = ffi.Void Function(
  ffi.Pointer<ffi.Int8> mountpoint,
  ffi.Pointer<fuse_chan> ch,
);

typedef _dart_fuse_unmount = void Function(
  ffi.Pointer<ffi.Int8> mountpoint,
  ffi.Pointer<fuse_chan> ch,
);

typedef _c_fuse_parse_cmdline = ffi.Int32 Function(
  ffi.Pointer<fuse_args> args,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
  ffi.Pointer<ffi.Int32> multithreaded,
  ffi.Pointer<ffi.Int32> foreground,
);

typedef _dart_fuse_parse_cmdline = int Function(
  ffi.Pointer<fuse_args> args,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
  ffi.Pointer<ffi.Int32> multithreaded,
  ffi.Pointer<ffi.Int32> foreground,
);

typedef _c_fuse_daemonize = ffi.Int32 Function(
  ffi.Int32 foreground,
);

typedef _dart_fuse_daemonize = int Function(
  int foreground,
);

typedef _c_fuse_version = ffi.Int32 Function();

typedef _dart_fuse_version = int Function();

typedef _c_fuse_pollhandle_destroy = ffi.Void Function(
  ffi.Pointer<fuse_pollhandle> ph,
);

typedef _dart_fuse_pollhandle_destroy = void Function(
  ffi.Pointer<fuse_pollhandle> ph,
);

typedef _c_fuse_buf_size = ffi.Int32 Function(
  ffi.Pointer<fuse_bufvec> bufv,
);

typedef _dart_fuse_buf_size = int Function(
  ffi.Pointer<fuse_bufvec> bufv,
);

typedef _c_fuse_buf_copy = ffi.Int64 Function(
  ffi.Pointer<fuse_bufvec> dst,
  ffi.Pointer<fuse_bufvec> src,
  ffi.Int32 flags,
);

typedef _dart_fuse_buf_copy = int Function(
  ffi.Pointer<fuse_bufvec> dst,
  ffi.Pointer<fuse_bufvec> src,
  int flags,
);

typedef _c_fuse_set_signal_handlers = ffi.Int32 Function(
  ffi.Pointer<fuse_session> se,
);

typedef _dart_fuse_set_signal_handlers = int Function(
  ffi.Pointer<fuse_session> se,
);

typedef _c_fuse_remove_signal_handlers = ffi.Void Function(
  ffi.Pointer<fuse_session> se,
);

typedef _dart_fuse_remove_signal_handlers = void Function(
  ffi.Pointer<fuse_session> se,
);

typedef _c_fuse_new = ffi.Pointer<fuse> Function(
  ffi.Pointer<fuse_chan> ch,
  ffi.Pointer<fuse_args> args,
  ffi.Pointer<fuse_operations> op,
  ffi.Int32 op_size,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_fuse_new = ffi.Pointer<fuse> Function(
  ffi.Pointer<fuse_chan> ch,
  ffi.Pointer<fuse_args> args,
  ffi.Pointer<fuse_operations> op,
  int op_size,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_fuse_destroy = ffi.Void Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_destroy = void Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_loop = ffi.Int32 Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_loop = int Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_exit = ffi.Void Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_exit = void Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_loop_mt = ffi.Int32 Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_loop_mt = int Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_getgroups = ffi.Int32 Function(
  ffi.Int32 size,
  ffi.Pointer<ffi.Uint32> list,
);

typedef _dart_fuse_getgroups = int Function(
  int size,
  ffi.Pointer<ffi.Uint32> list,
);

typedef _c_fuse_interrupted = ffi.Int32 Function();

typedef _dart_fuse_interrupted = int Function();

typedef _c_fuse_invalidate = ffi.Int32 Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_fuse_invalidate = int Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_fuse_is_lib_option = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> opt,
);

typedef _dart_fuse_is_lib_option = int Function(
  ffi.Pointer<ffi.Int8> opt,
);

typedef _c_fuse_start_cleanup_thread = ffi.Int32 Function(
  ffi.Pointer<fuse> fuse,
);

typedef _dart_fuse_start_cleanup_thread = int Function(
  ffi.Pointer<fuse> fuse,
);

typedef _c_fuse_stop_cleanup_thread = ffi.Void Function(
  ffi.Pointer<fuse> fuse,
);

typedef _dart_fuse_stop_cleanup_thread = void Function(
  ffi.Pointer<fuse> fuse,
);

typedef _c_fuse_clean_cache = ffi.Int32 Function(
  ffi.Pointer<fuse> fuse,
);

typedef _dart_fuse_clean_cache = int Function(
  ffi.Pointer<fuse> fuse,
);

typedef _c_fuse_fs_getattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<stat> buf,
);

typedef _dart_fuse_fs_getattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<stat> buf,
);

typedef _c_fuse_fs_fgetattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<stat> buf,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_fgetattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<stat> buf,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_rename = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> oldpath,
  ffi.Pointer<ffi.Int8> newpath,
);

typedef _dart_fuse_fs_rename = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> oldpath,
  ffi.Pointer<ffi.Int8> newpath,
);

typedef _c_fuse_fs_unlink = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_fuse_fs_unlink = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_fuse_fs_rmdir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_fuse_fs_rmdir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_fuse_fs_symlink = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> linkname,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_fuse_fs_symlink = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> linkname,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_fuse_fs_link = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> oldpath,
  ffi.Pointer<ffi.Int8> newpath,
);

typedef _dart_fuse_fs_link = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> oldpath,
  ffi.Pointer<ffi.Int8> newpath,
);

typedef _c_fuse_fs_release = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_release = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_open = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_open = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_read = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 size,
  ffi.Int64 off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_read = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  int size,
  int off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_read_buf = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Pointer<fuse_bufvec>> bufp,
  ffi.Int32 size,
  ffi.Int64 off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_read_buf = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Pointer<fuse_bufvec>> bufp,
  int size,
  int off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_write = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 size,
  ffi.Int64 off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_write = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  int size,
  int off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_write_buf = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_bufvec> buf,
  ffi.Int64 off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_write_buf = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_bufvec> buf,
  int off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_fsync = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 datasync,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_fsync = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int datasync,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_flush = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_flush = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_statfs = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<statvfs> buf,
);

typedef _dart_fuse_fs_statfs = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<statvfs> buf,
);

typedef _c_fuse_fs_opendir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_opendir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef fuse_fill_dir_t = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<stat>,
  ffi.Int64,
);

typedef _c_fuse_fs_readdir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Void> buf,
  ffi.Pointer<ffi.NativeFunction<fuse_fill_dir_t>> filler,
  ffi.Int64 off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_readdir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Void> buf,
  ffi.Pointer<ffi.NativeFunction<fuse_fill_dir_t>> filler,
  int off,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_fsyncdir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 datasync,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_fsyncdir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int datasync,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_releasedir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_releasedir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_create = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_create = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_lock = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  ffi.Int32 cmd,
  ffi.Pointer<flock> lock,
);

typedef _dart_fuse_fs_lock = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  int cmd,
  ffi.Pointer<flock> lock,
);

typedef _c_fuse_fs_flock = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  ffi.Int32 op,
);

typedef _dart_fuse_fs_flock = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  int op,
);

typedef _c_fuse_fs_chmod = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
);

typedef _dart_fuse_fs_chmod = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mode,
);

typedef _c_fuse_fs_chown = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 uid,
  ffi.Uint32 gid,
);

typedef _dart_fuse_fs_chown = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int uid,
  int gid,
);

typedef _c_fuse_fs_truncate = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int64 size,
);

typedef _dart_fuse_fs_truncate = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int size,
);

typedef _c_fuse_fs_ftruncate = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int64 size,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_ftruncate = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int size,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_utimens = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<timespec> tv,
);

typedef _dart_fuse_fs_utimens = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<timespec> tv,
);

typedef _c_fuse_fs_access = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 mask,
);

typedef _dart_fuse_fs_access = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mask,
);

typedef _c_fuse_fs_readlink = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 len,
);

typedef _dart_fuse_fs_readlink = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> buf,
  int len,
);

typedef _c_fuse_fs_mknod = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
  ffi.Uint64 rdev,
);

typedef _dart_fuse_fs_mknod = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  int rdev,
);

typedef _c_fuse_fs_mkdir = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
);

typedef _dart_fuse_fs_mkdir = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mode,
);

typedef _c_fuse_fs_setxattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  ffi.Int32 size,
  ffi.Int32 flags,
);

typedef _dart_fuse_fs_setxattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  int size,
  int flags,
);

typedef _c_fuse_fs_getxattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  ffi.Int32 size,
);

typedef _dart_fuse_fs_getxattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
  int size,
);

typedef _c_fuse_fs_listxattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> list,
  ffi.Int32 size,
);

typedef _dart_fuse_fs_listxattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> list,
  int size,
);

typedef _c_fuse_fs_removexattr = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_fuse_fs_removexattr = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_fuse_fs_bmap = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 blocksize,
  ffi.Pointer<ffi.Uint64> idx,
);

typedef _dart_fuse_fs_bmap = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int blocksize,
  ffi.Pointer<ffi.Uint64> idx,
);

typedef _c_fuse_fs_ioctl = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 cmd,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<fuse_file_info> fi,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_fuse_fs_ioctl = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int cmd,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<fuse_file_info> fi,
  int flags,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_fuse_fs_poll = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  ffi.Pointer<fuse_pollhandle> ph,
  ffi.Pointer<ffi.Uint32> reventsp,
);

typedef _dart_fuse_fs_poll = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<fuse_file_info> fi,
  ffi.Pointer<fuse_pollhandle> ph,
  ffi.Pointer<ffi.Uint32> reventsp,
);

typedef _c_fuse_fs_fallocate = ffi.Int32 Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 mode,
  ffi.Int64 offset,
  ffi.Int64 length,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _dart_fuse_fs_fallocate = int Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  int offset,
  int length,
  ffi.Pointer<fuse_file_info> fi,
);

typedef _c_fuse_fs_init = ffi.Void Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<fuse_conn_info> conn,
);

typedef _dart_fuse_fs_init = void Function(
  ffi.Pointer<fuse_fs> fs,
  ffi.Pointer<fuse_conn_info> conn,
);

typedef _c_fuse_fs_destroy = ffi.Void Function(
  ffi.Pointer<fuse_fs> fs,
);

typedef _dart_fuse_fs_destroy = void Function(
  ffi.Pointer<fuse_fs> fs,
);

typedef _c_fuse_notify_poll = ffi.Int32 Function(
  ffi.Pointer<fuse_pollhandle> ph,
);

typedef _dart_fuse_notify_poll = int Function(
  ffi.Pointer<fuse_pollhandle> ph,
);

typedef _c_fuse_fs_new = ffi.Pointer<fuse_fs> Function(
  ffi.Pointer<fuse_operations> op,
  ffi.Int32 op_size,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_fuse_fs_new = ffi.Pointer<fuse_fs> Function(
  ffi.Pointer<fuse_operations> op,
  int op_size,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_fuse_register_module = ffi.Void Function(
  ffi.Pointer<fuse_module> mod,
);

typedef _dart_fuse_register_module = void Function(
  ffi.Pointer<fuse_module> mod,
);

typedef _c_fuse_setup = ffi.Pointer<fuse> Function(
  ffi.Int32 argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<fuse_operations> op,
  ffi.Int32 op_size,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
  ffi.Pointer<ffi.Int32> multithreaded,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _dart_fuse_setup = ffi.Pointer<fuse> Function(
  int argc,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> argv,
  ffi.Pointer<fuse_operations> op,
  int op_size,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> mountpoint,
  ffi.Pointer<ffi.Int32> multithreaded,
  ffi.Pointer<ffi.Void> user_data,
);

typedef _c_fuse_teardown = ffi.Void Function(
  ffi.Pointer<fuse> fuse,
  ffi.Pointer<ffi.Int8> mountpoint,
);

typedef _dart_fuse_teardown = void Function(
  ffi.Pointer<fuse> fuse,
  ffi.Pointer<ffi.Int8> mountpoint,
);

typedef _c_fuse_read_cmd = ffi.Pointer<fuse_cmd> Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_read_cmd = ffi.Pointer<fuse_cmd> Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_process_cmd = ffi.Void Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<fuse_cmd> cmd,
);

typedef _dart_fuse_process_cmd = void Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<fuse_cmd> cmd,
);

typedef fuse_processor_t = ffi.Void Function(
  ffi.Pointer<fuse>,
  ffi.Pointer<fuse_cmd>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_fuse_loop_mt_proc = ffi.Int32 Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<ffi.NativeFunction<fuse_processor_t>> proc,
  ffi.Pointer<ffi.Void> data,
);

typedef _dart_fuse_loop_mt_proc = int Function(
  ffi.Pointer<fuse> f,
  ffi.Pointer<ffi.NativeFunction<fuse_processor_t>> proc,
  ffi.Pointer<ffi.Void> data,
);

typedef _c_fuse_exited = ffi.Int32 Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_exited = int Function(
  ffi.Pointer<fuse> f,
);

typedef _c_fuse_get_session = ffi.Pointer<fuse_session> Function(
  ffi.Pointer<fuse> f,
);

typedef _dart_fuse_get_session = ffi.Pointer<fuse_session> Function(
  ffi.Pointer<fuse> f,
);

typedef _typedefC_1 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<stat>,
);

typedef _typedefC_2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef fuse_dirfil_t = ffi.Int32 Function(
  ffi.Pointer<fuse_dirhandle>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Uint64,
);

typedef _typedefC_3 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_dirhandle>,
  ffi.Pointer<ffi.NativeFunction<fuse_dirfil_t>>,
);

typedef _typedefC_4 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Uint64,
);

typedef _typedefC_5 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
);

typedef _typedefC_6 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_7 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_8 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_9 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_10 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_11 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
);

typedef _typedefC_12 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Uint32,
);

typedef _typedefC_13 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int64,
);

typedef _typedefC_14 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<utimbuf>,
);

typedef _typedefC_15 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_16 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_17 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_18 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<statvfs>,
);

typedef _typedefC_19 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_20 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_21 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_22 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int32,
);

typedef _typedefC_23 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_24 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_25 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
);

typedef _typedefC_26 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_27 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.NativeFunction<fuse_fill_dir_t>>,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_28 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_29 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_30 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<fuse_conn_info>,
);

typedef _typedefC_31 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_32 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_33 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_34 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_35 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<stat>,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_36 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
  ffi.Int32,
  ffi.Pointer<flock>,
);

typedef _typedefC_37 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<timespec>,
);

typedef _typedefC_38 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Uint64>,
);

typedef _typedefC_39 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<fuse_file_info>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_40 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
  ffi.Pointer<fuse_pollhandle>,
  ffi.Pointer<ffi.Uint32>,
);

typedef _typedefC_41 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_bufvec>,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_42 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Pointer<fuse_bufvec>>,
  ffi.Int32,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_43 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<fuse_file_info>,
  ffi.Int32,
);

typedef _typedefC_44 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int64,
  ffi.Int64,
  ffi.Pointer<fuse_file_info>,
);

typedef _typedefC_45 = ffi.Pointer<fuse_fs> Function(
  ffi.Pointer<fuse_args>,
  ffi.Pointer<ffi.Pointer<fuse_fs>>,
);
